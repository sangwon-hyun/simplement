[["index.html", "Creating the simplement R package 1 Introduction", " Creating the simplement R package Sangwon Hyun 2024-06-19 1 Introduction This package implements simplement, an R package with some commonly used simulation and implementation helpers. The documentation and package are both created using one simple command: litr::render(&quot;index.Rmd&quot;, output_format = litr::litr_gitbook()) "],["package-setup.html", "2 Package setup", " 2 Package setup The DESCRIPTION file is created using this code. usethis::create_package( path = &quot;.&quot;, fields = list( Package = params$package_name, Version = &quot;0.0.0.9000&quot;, Title = &quot;flowtrend&quot;, Description = &quot;Time-smooth mixture modeling for flow cytometry data.&quot;, `Authors@R` = person( given = &quot;Sangwon&quot;, family = &quot;Hyun&quot;, email = &quot;sangwonh@ucsc.edu&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;) ) ) ) usethis::use_mit_license(copyright_holder = &quot;Sangwon Hyun&quot;) The following is what will show up when someone types package?flowtrend in the console. #&#39; flowtrend #&#39; #&#39; This package implements the `flowtrend` method for automatic gating of flow cytometry data using trend filtering. #&#39; #&#39; @docType package This package will have some dependancies: library(tidyverse) library(ggplot2) usethis::use_package(&quot;tidyverse&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;ggplot2&quot;) usethis::use_pipe() usethis::use_package(&quot;glmnet&quot;) usethis::use_package(&quot;clue&quot;) "],["simulation-helpers.html", "3 Simulation helpers 3.1 Helper to parse arguments from the command line 3.2 Helper to create a folder if it doesn’t exist. 3.3 Helper to divide jobs into ‘chunks’", " 3 Simulation helpers 3.1 Helper to parse arguments from the command line We’ll define a function called parse_args() to parse trailing arguments to Rscript. Let’s say we ran something like this: Rscript gradients.R\\ gradients_num=1\\ arraynum=$SLURM_ARRAY_TASK_ID\\ arraynum_max=$SLURM_ARRAY_TASK_MAX\\ summ=1 exit 0 Then, the R script gradients.R can include this: parse_args(args = commandArgs(trailingOnly = TRUE), verbose=TRUE) to have access to the arguments gradients_num, arraynum, arraynum_max, and summ. ##&#39; Parse command line arguments and assigns the values of them. |args| is meant ##&#39; to just be additional command line arguments. ##&#39; ##&#39; @param args Argument. ##&#39; ##&#39; @examples \\dontrun{parse_args(args = commandArgs(trailingOnly = TRUE))} ##&#39; parse_args &lt;- function(args, verbose=FALSE){ args = sapply(args, strsplit, &quot;=&quot;) print(args) for(arg in args){ ## Check if the thing is integer all_numbers = str_detect(arg[2], &quot;^[:digit:]+$&quot;) print(all_numbers) ## Assign the variable if(all_numbers){ assign(arg[1], as.numeric(arg[2]), inherits = TRUE) } else { assign(arg[1], arg[2], inherits = TRUE) } if(verbose){ cat(arg[1], &quot;takes the value of&quot;, arg[2], &quot;from command line input&quot;, fill=TRUE) } print(&quot;===============================&quot;) } } 3.2 Helper to create a folder if it doesn’t exist. ##&#39; Creates a directory \\code{destin}, if it doesn&#39;t already exist. ##&#39; ##&#39; @param destin Destination directory. ##&#39; ##&#39; @export create_destin &lt;- function(destin){ if(!dir.exists(destin)){ dir.create(destin, recursive = TRUE) cat(&quot;Creating destin: &quot;, destin, fill=TRUE) } else { cat(&quot;All output goes out to destin: &quot;, destin, fill = TRUE) } } 3.3 Helper to divide jobs into ‘chunks’ Take a long matrix iimat whose rows encode the configuration of jobs you want to run. For instance, flowmix::make_iimat() makes a long matrix whose rows look like this: ##&#39; ind ialpha ibeta ifold irep ##&#39; 55 6 1 2 1 ##&#39; 56 7 1 2 1 ##&#39; 57 1 2 2 1 ##&#39; 58 2 2 2 1 ##&#39; 59 3 2 2 1 ##&#39; 60 4 2 2 1 And flowtrend::make_iimat() makes a matrix whose rows look like this: #&#39; ind iprob imu ifold irestart #&#39; 55 6 1 2 1 #&#39; 56 7 1 2 1 #&#39; 57 1 2 2 1 #&#39; 58 2 2 2 1 #&#39; 59 3 2 2 1 #&#39; 60 4 2 2 1 The helper function make_iilist() will help you divide this into arraynum_max jobs. This is useful if you are running many pre-defined jobs and want SLURM to help you get arraynum_max==100 cores to run these jobs. ##&#39; Helper to divide up the jobs in \\code{iimat} into a total of ##&#39; \\code{arraynum_max} jobs. The purpose is to divide the jobs, in order to run ##&#39; this on a server. ##&#39; ##&#39; @param arraynum_max Maximum SLURM array number. ##&#39; @param iimat matrix whose rows contain CV job indices. ##&#39; ##&#39; @export make_iilist &lt;- function(arraynum_max, iimat){ iimax = nrow(iimat) if(arraynum_max &gt; iimax){ iilist = lapply(1:iimax, function(a)a) } else { ends = round(seq(from=0, to=iimax, length=arraynum_max+1)) iilist = Map(function(a,b){ (a+1):b}, ends[-length(ends)], ends[-1]) stopifnot(length(unlist(iilist)) == nrow(iimat)) } stopifnot(length(unlist(iilist)) == nrow(iimat)) stopifnot(all(sort(unique(unlist(iilist))) == sort(unlist(iilist)))) return(iilist) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
